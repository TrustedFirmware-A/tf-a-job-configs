/*
 * Copyright (c) 2025, Arm Limited and Contributors. All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

pipeline {
    agent {
        label 'docker-amd64-tf-a-jammy'
    }

    parameters {
        string(
            name: 'URL',
            defaultValue: "https://review.trustedfirmware.org/${env.GERRIT_PROJECT_PREFIX}shared/transfer-list-library",
            description: 'Repository URL.')

        string(
            name: 'REFSPEC',
            defaultValue: '+refs/heads/main',
            description: 'Git refspec used when fetching.')

        string(
            name: 'REFNAME',
            defaultValue: 'FETCH_HEAD',
            description: 'Git refname of the first commit to check.')

        string(
            name: 'BASE_REFSPEC',
            defaultValue: '+refs/heads/main',
            description: 'Git refspec of the parent of the last commit to check.')

        string(
            name: 'BASE_REFNAME',
            defaultValue: 'FETCH_HEAD',
            description: 'Git refname of the parent of the first last commit to check.')
    }

   stages {
        stage('Checkout') {
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[ name: params.REFNAME ]],
                    // TODO: shallow clone
                    extensions: [ cloneOption(honorRefspec: true) ],
                    userRemoteConfigs: [
                        [ url: params.URL, refspec: "${params.BASE_REFSPEC} ${params.REFSPEC}" ]
                    ]
                ])

                sh "git show --no-patch HEAD" // TODO: remove me after testing
            }
        }

        stage('Code style') {
            steps {
                script {
                    sh "git-clang-format ${params.BASE_REF} HEAD --diff -q | tee formatted.patch"
                    sh "[ -s formatted.patch ] || rm formatted.patch"

                    if (fileExists('formatted.patch')) {
                        archiveArtifacts artifacts: "formatted.patch", fingerprint: true
                        error("Code style check failed. See 'formatted.patch' for suggested changes.")
                    }
                }
           }
        }

        stage('Build') {
            matrix {
                axes {
                    axis {
                        name 'COMPILER'
                        values 'aarch64-clang', 'aarch64-gcc', 'aarch32-clang', 'aarch32-gcc', 'clang', 'gcc'
                    }

                    axis {
                        name 'BUILD_TYPE'
                        values 'Debug', 'Release', 'RelWithDebInfo', 'MinSizeRel'
                    }
                }

                stages {
                    stage('Compile') {
                        steps {
                            script {
                                def toolchains = [
                                    'gcc': [
                                        cc: 'gcc',
                                        cmakeArgs: [],
                                    ],

                                    'clang': [
                                        cc: 'clang',
                                        cmakeArgs: [],
                                    ],

                                    'aarch32-gcc': [
                                        cc: 'arm-none-eabi-gcc',
                                        cmakeArgs: ['-DCMAKE_TRY_COMPILE_TARGET_TYPE=STATIC_LIBRARY'],
                                    ],

                                    'aarch64-gcc': [
                                        cc: 'aarch64-none-elf-gcc',
                                        cmakeArgs: ['-DCMAKE_TRY_COMPILE_TARGET_TYPE=STATIC_LIBRARY'],
                                    ],

                                    'aarch32-clang': [
                                        cc: 'clang',
                                        clangTarget: 'arm-none-eabi',
                                        cmakeArgs: ['-DCMAKE_TRY_COMPILE_TARGET_TYPE=STATIC_LIBRARY'],
                                    ],

                                    'aarch64-clang': [
                                        cc: 'clang',
                                        clangTarget: 'aarch64-none-elf',
                                        cmakeArgs: ['-DCMAKE_TRY_COMPILE_TARGET_TYPE=STATIC_LIBRARY'],
                                    ],
                                ]

                                def buildDir = "build/${COMPILER}/${BUILD_TYPE}"
                                def cmakeArgs = toolchains[COMPILER].cmakeArgs

                                cmakeArgs << "-DCMAKE_C_COMPILER=${toolchains[COMPILER].cc}"

                                if (toolchains[COMPILER].clangTarget) {
                                    def sysroot = sh(
                                        script: "${toolchains[COMPILER].clangTarget}-gcc -print-sysroot",
                                        returnStdout: true
                                    ).trim()

                                    cmakeArgs << "-DCMAKE_C_COMPILER_TARGET=${toolchains[COMPILER].clangTarget}"
                                    cmakeArgs << "-DCMAKE_SYSROOT=${sysroot}"
                                }

                                sh """
                                    cmake -B ${buildDir} -DCMAKE_BUILD_TYPE=${BUILD_TYPE} ${cmakeArgs.join(' ')}
                                    cmake --build ${buildDir}
                                """
                            }
                        }

                        post {
                            always {
                                archiveArtifacts artifacts: "build/${COMPILER}/${BUILD_TYPE}/**", fingerprint: true
                            }
                        }
                    }
                }
            }
        }

        stage('Test') {
            steps {
                script {
                    def testDir = "build/test"

                    sh """
                        CC=clang cmake -B ${testDir} -DTARGET_GROUP=test
                        cmake --build ${testDir}
                    """
                    sh "cmake --build ${testDir} -- test"
                }

            }

            post {
                always {
                        archiveArtifacts artifacts: "build/test/**", fingerprint: true
                }
            }
        }
    }
}
